/*
  Stories - an interactive storytelling language
  Copyright (C) 2017 Luka Jovičić

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package rs.lukaj.stories.parser;

import rs.lukaj.stories.Utils;
import rs.lukaj.stories.exceptions.InterpretationException;
import rs.lukaj.stories.parser.lines.*;
import rs.lukaj.stories.runtime.Chapter;
import rs.lukaj.stories.runtime.State;

public enum LineType {
    ANSWER {
        @Override
        public Line parse(String line, int lineNumber, int indent, Chapter chapter)
                throws InterpretationException {
           String[] tokens = line.split("\\s*(]|\\[)\\s*", 3);
            if(tokens.length < 3)
                throw new InterpretationException("No variable for answer");
            Line ans;
            if(chapter.imageExists(tokens[1])) {
                ans = new PictureAnswer(chapter, tokens[1], chapter.getImage(tokens[2]), lineNumber, indent);
            } else {
                ans = new Answer(chapter, tokens[1], tokens[2], lineNumber, indent);
            }
            //we're being quite strict here: disallowing mixing of image and String, even if
            //String only looks like an image. An alternative would be falling back to
            //String in case Question detects mixing, though I'm afraid that'd make things
            //quite complicated and unpredictable todo reconsider
            return ans;
        }

        @Override
        public boolean matches(String line, State state) {
            return !escaped(state) && line.startsWith("*");
        }

        /**
         * @inheritDoc
         * [0] - variable
         * [1] - answer
         * @param params
         * @return
         */
        @Override
        public String makeLine(String... params) {
            if(params.length != 2) throw new IllegalArgumentException("Wrong params for ANSWER Line generation");
            return "* [" + params[0] + "] " + params[1];
        }
    },
    STATEMENT {
        @Override
        public Line parse(String line, int lineNumber, int indent, Chapter chapter)
                throws InterpretationException {
            if(line.startsWith(":")) line = line.substring(1);
            //^ it doesn't have to start with : - e.g. in statement blocks
            return Statement.create(chapter, line, lineNumber, indent);
        }

        @Override
        public boolean matches(String line, State state) {
            return !escaped(state) && (insideStatementBlock(state) || line.startsWith(":"));
        }

        /**
         * @inheritDoc
         * [0] - statement line, as generated by Statement class
         * @param params
         * @return
         */
        @Override
        public String makeLine(String... params) {
            if (params.length != 1) throw new IllegalArgumentException("Wrong params for STATEMENT line");
            return ":" + params[0];
        }
    },
    NARRATIVE {
        @Override
        public Line parse(String line, int lineNumber, int indent, Chapter chapter)
                throws InterpretationException {
            return new Narrative(chapter, line, lineNumber, indent);
        }

        @Override
        public boolean matches(String line, State state) {
            return true;
        }

        /**
         * Returns escaped narrative line.
         * [0] - narrative text
         * @param params
         * @return
         */
        @Override
        public String makeLine(String... params) {
            return "\\" + params[0];
        }
    },
    QUESTION {
        @Override
        public Line parse(String line, int lineNumber, int indent, Chapter chapter)
                throws InterpretationException {
            if(!line.contains(":")) line = line + ":"; //todo fix this, make shared code for narrative/speech and recognizing it in questions

            String[] parts = line.substring(1).split("\\s*:\\s*", 2);
            String text = parts[1];
            String var = Utils.between(parts[0], '[', ']');
            String time = Utils.between(parts[0], '(', ')');
            String charName;
            if(parts[0].indexOf("]") > parts[0].indexOf(")"))
                charName = Utils.between(line, ']', ':');
            else
                charName = Utils.between(line, ')', ':');
            if(time != null) time = time.trim();
            if(var == null) throw new InterpretationException("Variable name for question is empty");
            charName = charName.trim(); //this shouldn't be null (both ] and : must exist, otherwise NPE would be thrown earlier)
            var = var.trim();

            if(time == null) {
                return new Question(chapter, var, text, charName, lineNumber, indent);
            } else {
                double coeff=1;
                if(time.endsWith("ms")) {
                    coeff = 1./1000;
                    time = time.substring(0, time.length()-2);
                } else if(time.endsWith("s")) {
                    coeff = 1;
                    time = time.substring(0, time.length()-1);
                } else if(time.endsWith("m")) {
                    coeff = 60;
                    time = time.substring(0, time.length()-1);
                }
                try {
                    double seconds = Double.parseDouble(time) * coeff;
                    return new TimedQuestion(chapter, var, text, charName, seconds, lineNumber, indent);
                } catch (NumberFormatException e) {
                    throw new InterpretationException("Invalid number for time!", e);
                }
            }
        }

        @Override
        public boolean matches(String line, State state) {
            return !escaped(state) && line.startsWith("?");
        }

        /**
         * @inheritDoc
         * [0] - variable
         * [1] - time in seconds, or "0" for unlimited
         * [2] - character
         * [3] - question text
         * @param params
         * @return
         */
        @Override
        public String makeLine(String... params) {
            if(params.length != 4) throw new IllegalArgumentException("Wrong params for QUESTION line");
            if(params[1].equals("0.0"))
                return "?[" + params[0] + "] " + params[2] + ": " + params[3];
            else
                return "?[" + params[0] + "] (" + params[1] + "s) " + params[2] + ": " + params[3];
        }
    },
    SPEECH {
        @Override
        public Line parse(String line, int lineNumber, int indent, Chapter chapter)
                throws InterpretationException {
            String[] parts = line.split("\\s*:\\s*", 2);
            return new Speech(chapter, parts[0], parts[1], lineNumber, indent);
        }

        @Override
        public boolean matches(String line, State state) {
            return line.contains(":") && state.hasVariable(line.split("\\s*:", 2)[0]);
        }

        /**
         * @inheritDoc
         * Returns escaped speech line
         * [0] - character
         * [1] - speech text
         * @param params
         * @return
         */
        @Override
        public String makeLine(String... params) {
            if(params.length != 2) throw new IllegalArgumentException("Wrong params for SPEECH line");
            return "\\" + params[0] + ": " + params[1];
        }
    },
    INPUT {
        @Override
        public Line parse(String line, int lineNumber, int indent, Chapter chapter)
                throws InterpretationException {
            String[] parts = line.split("\\s*]\\s*", 2);
            return new TextInput(chapter, parts[0].substring(1), parts[1], lineNumber, indent);
        }

        @Override
        public boolean matches(String line, State state) {
            return !escaped(state) && line.startsWith("[") && line.contains("]");
        }

        /**
         * @inheritDoc
         * [0] - variable name
         * [1] - hint
         * @param params
         * @return
         */
        @Override
        public String makeLine(String... params) {
            if(params.length != 2) throw new IllegalArgumentException("Wrong params for INPUT line");
            return "[" + params[0] + "] " + params[1];
        }
    },
    COMMENT {
        @Override
        public Line parse(String line, int lineNumber, int indent, Chapter chapter)
                throws InterpretationException {
            return new Nop(chapter, lineNumber, indent); //this is a no-op
        }

        @Override
        public boolean matches(String line, State state) {
            return !escaped(state) && (line.isEmpty() || line.startsWith("//"));
        }

        /**
         * @inheritDoc
         * [0] - comment text
         * @param params
         * @return
         */
        @Override
        public String makeLine(String... params) {
            if(params.length != 1) throw new IllegalArgumentException("Wrong params for COMMENT line");
            return "//" + params[0];
        }
    },
    DIRECTIVE {
        @Override
        public Line parse(String line, int lineNumber, int indent, Chapter chapter) throws InterpretationException {
            return new Directive(chapter, lineNumber, indent, line.substring(1));
        }

        @Override
        public boolean matches(String line, State state) {
            return !escaped(state) && line.startsWith("#");
        }

        @Override
        public String makeLine(String... params) {
            if(params.length != 1) throw new IllegalArgumentException("Wrong params for DIRECTIVE line");
            return "#" + params[0];
        }
    },
    STATEMENT_BLOCK_MARKER {
        @Override
        public Line parse(String line, int lineNumber, int indent, Chapter chapter)
                throws InterpretationException {
            return new Nop(chapter, lineNumber, Utils.countLeadingSpaces(line)); //this is awkward (also disables generation)
        }

        @Override
        public boolean matches(String line, State state) {
            return !escaped(state) && line.equals(":::");
        }

        @Override
        public String makeLine(String... params) {
            if(params.length != 0) throw new IllegalArgumentException("Wrong params for STATEMENT_BLOCK_MARKER line");
            return ":::";
        }
    },
    END_CHAPTER {
        @Override
        public Line parse(String line, int lineNumber, int indent, Chapter chapter) throws InterpretationException {
            return new EndChapter(chapter, lineNumber, indent);
        }

        @Override
        public boolean matches(String line, State state) {
            return !escaped(state) && line.equals(";;");
        }

        @Override
        public String makeLine(String... params) {
            if(params.length != 0) throw new IllegalArgumentException("Wrong params for END_CHAPTER line");
            return ";;";
        }
    };

    /**
     * Parse given string to line. String should be trimmed, stripped of starting
     * backslashes and comments.
     * @param line properly formatted string
     * @param lineNumber this line's number
     * @param indent indentation of this line
     * @param chapter chapter this line belongs to
     * @return parsed Line
     * @throws InterpretationException in case any error during parsing occurs
     */
    public abstract Line parse(String line, int lineNumber, int indent, Chapter chapter)
            throws InterpretationException;
    public abstract boolean matches(String line, State state);

    /**
     * Generate a line with syntax appropriate for the type, based on passed params.
     * @param params contains data for generating the line, different for each line type
     * @return line which when parsed returns an appropriate parser.lines.* representation
     */
    public abstract String makeLine(String... params);

    public static final LineType[] PRECEDENCE = new LineType[]
            {COMMENT, DIRECTIVE, STATEMENT_BLOCK_MARKER, STATEMENT, END_CHAPTER, QUESTION, ANSWER, INPUT, SPEECH, NARRATIVE};

    private static final String STATE_KEY_ESCAPED = "__!escaped__";
    private static final String STATE_KEY_INSIDE_BLOCK = "__!insideStatementBlock__";
    private static boolean escaped(State state) {
        return state.getBool(STATE_KEY_ESCAPED);
    }
    private static boolean insideStatementBlock(State state) {
        return state.getBool(STATE_KEY_INSIDE_BLOCK);
    }

    public static LineType getType(String line, State state, boolean escaped, boolean insideStatementBlock)
            throws InterpretationException {
        state.setVariable(STATE_KEY_ESCAPED, escaped);
        state.setVariable(STATE_KEY_INSIDE_BLOCK, insideStatementBlock);
        for(LineType t : PRECEDENCE)
            if(t.matches(line, state))
                return t;

        throw new RuntimeException("No viable type for line: " + line);
    }
}
